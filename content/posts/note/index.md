---
title: "Note"
date: 2020-01-03T16:08:31+08:00
draft: true
---

## Redis笔记

#### Redis基础

1. 为什么要用 Redis？

   答：因为传统的关系型数据库如 Mysql 已经不能适用所有的场景，比如秒杀的库存扣减，APP首页的访问流量高峰等，都很容易把数据库打崩，所以引入了Redis。

2. Redis有哪些数据结构？

   答：**String**、**Hash**、**List**、**Set**、**SortedSet**

3. 如果有大量的key需要设置同一时间过期，一般需要注意什么？

   答：如果大量的key过期时间设置的过于集中，到过期的时间点，Redis可能会出现短暂的卡顿现象。严重的话可能会引起**缓存雪崩**。

   解决：我们一般需要**在时间上加一个随机值，使得过期时间分散一些**。

4. 那你使用过分布式锁么，它是怎么一回事？

   答：先拿**setnx**来争抢锁，再用**expire**给锁加一个过期时间防止锁忘记释放。

5. 接上，如果在setnx之后执行expire之前，进程意外crash或者被重启了，怎么办？

   答：可以把 setnx、expire 两条命令合并成一个命令，进行原子操作。

6. 加入有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？

   答：使用 **keys** 命令可以取出指定模式的 key 列表

7. 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？

   答：Redis是单线程的，keys指令会导致线程阻塞一段时间，**线上业务会被停顿**，直到指令执行完毕，服务才能恢复。

   解决：可以使用**scan**命令，scan命令可以无阻塞的提取出指定模式的key列表，但是有一定的重复概率，在客户端做一次去重九可以了。

8. 使用过Redis做异步队列么，你是怎么用的？

   答：一般使用**list**结构作为队列，**rpush**生产消息，**lpop**消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

9. 如果对方追问可不可以不用sleep呢？

   答：使用**blpop**，在没有消息的时候，它会阻塞直到消息到来。

10. 如果对方接着追问能不能生产一次消费多次呢？

    答：使用**pub/sub**主题订阅者模式，可以实现 1:N​

11. 如果对方继续追问 pub/sub 有什么缺点？

    答：在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等

12. 如果对方究极TM追问Redis如何实现延时队列？

    答：使用**sortedset**，拿时间戳作为**score**，消息内容作为key，调用zadd来生产消息，消费者用**zrangebyscore**指令获取N秒前的数据，轮询进行处理。

13. Redis是怎么持久化的？服务主从数据怎么交互的？

    答：**RDB做镜像全量持久化，AOF做增量持久化**。因为RDB会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要AOF来配合使用。Redis本身的机制时AOF持久化开启且存在AOF时，优先加载AOF文件；AOF关闭或者AOF文件不存在时，加载RDB文件；加载AOF/RDB文件后，Redis启动成功。若AOF/RDB文件存在错误，Redis启动失败，并打印错误信息。

14. 如果机器突然掉点怎么办？

    答：取决于**AOF的sync属性的配置**，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据，但是为了保证高性能，每次都sync是不现实的，一般都使用定时sync，比如1秒1次，这个时候最多就丢失1秒钟的数据。

15. RDB的原理是什么？

    **fork**和**cow**，即fork和copy on write。fork是指redis通过创建子进程来进行RDB操作，cow指子进程创建后，父子进程共享数据段，**父进程继续提供读写服务**，写脏的数据页数据会逐渐和子进程分离开来。

16. pipeline有什么好处，为什么要用pipeline？

    答：可以将多次IO往返的时间缩短至一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

17. Redis的同步机制了解么？

    答：Redis可以使用主从同步，从从同步。第一次同步时，主节点做一次**bgsave**，并同时将后续修改操作记录到内存buffer，**待完成后将RDB文件全量同步到复制节点，复制节点接受完成后将RDB镜像加载到内存。**加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。后续的增量数据通过AOF日志同步即可，有点类似数据库的binlog。

18. 是否使用过Redis集群，集群的高可用怎么保证，集群的原理是什么？

    **Redis Sentinal**着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。

    **Redis Cluster**着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。

#### Redis缓存相关

**缓存雪崩，穿透，击穿**

1. Redis缓存雪崩了解吗？

   答：如果在同一时间，缓存大面积失效，那一瞬间Redis跟没有一样，那这个数量界别的请求直接打到数据库几乎是灾难性的。**由于原有缓存失效，新缓存未到期间(例如：我们设置缓存时采用了相同的过期时间，在同一时刻出现大面积的缓存过期)，所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。从而形成一系列连锁反应，造成整个系统崩溃。**

2. 如何应对缓存雪崩？

   答：处理缓存雪崩很简单，

   1. 在批量往Redis存数据的时候，把每个Key的实效时间都加个**随机值**就好了，这样可以保证数据不会再同一时间大面积失效。（失效时间随机）

   2. 如果Redis时集群部署，将热点数据均匀分布在不同的Redis库中也能避免全部失效的问题

   3. 设置热点数据永远不过期，有更新操作就直接更新缓存，而不会导致缓存失效

3. 那你了解缓存穿透和击穿吗？可以说他们跟雪崩的区别吗？

   答：

   - 缓存穿透：**缓存和数据库中都没有数据**，这是一个无效的查询。这时的用户很可能是攻击者，攻击会导致数据库压力过大，严重会击垮数据库。
     - 采用**布隆过滤器**，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
     - 如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。通过这个直接设置的默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴！
   - 缓存击穿：缓存击穿是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当**这个key在失效的瞬间，持续的大并发就击穿缓存，直接请求数据库，就像在一个完好无损的桶上凿出一个洞**。

4. 那他们分别怎么解决？

   缓存穿透：

   - 在接口层增加校验，比如用户鉴权，参数校验，不合法的参数直接返回
   - 从缓存中取不到数据，在数据库中也没有取到，这是也可以将对应的key的value写为null，写到redis数据库中，缓存有效时间可以设置短一点，比如30s

5. 你还有什么别的办法吗？

   答：

   - 缓存穿透：使用**布隆过滤器**，redis的高级用法，能够很好的防止缓存穿透的发生，虽然布隆过滤器存在误判的风险，但是对于存在的数据，绝不会误判，所以少部分的误判导致的缓存穿透，我们是能够接受的。

   - 缓存击穿：设置热点数据永不过期，或者加上互斥锁就可以了。

##### 一般避免以上情况发生，我们从三个时间段去分析：

- 事前：Redis 高可用，主从+哨兵，Redis 集群，避免全局崩溃

- 事中：本地 ehcache 缓存 + Hystrix 限流 + 降级， 避免 MySQL 被打死
- 事后：Redis 持久化 RDB + AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。

限流组件，可以设置每秒的请求，有多少能够通过组件，剩余的未通过的请求怎么办？**走降级**，可以返回一些默认的值，或者友情提示。

**好处**：

数据库绝对不会死，限流组件确保了每秒只有多少个请求能够通过，只要数据库不死，对用户来说，3/5的请求都是可以被处理的。只要有3/5的请求可以被处理，就意味着你的系统没有死，**对用户来说，可能就是点击几次刷不出来页面，但是多点几次，就可以刷出来一次。**



#### Redis哨兵、持久化、主从、手撕LRU

1. Redis为什么这么快？

   答：传统的关系型数据库的数据是存放在磁盘上面的，我们通过索引查找到数据指针，找到数据的指针之后，在从磁盘上获取数据，这是一个十分耗时的参数。

   Redis采用的是基于内存的、单进程单线程模型的KV数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。

   - 完全基于内存，绝大部分请求是存粹的内存操作，非常快速。redis的数据全部存储在内存中，类似于HashMap。
   - 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的。
   - 采用单线程，避免不必要的上下文切换和竞争条件，也不存在多进程或者多线程的切换而消耗**CPU**，不用去考虑各种锁的问题，不存在加锁释放锁操作，也不用担心死锁而导致的性能损耗。
   - 采用多路I/O复用模型，非阻塞I/O
   - 采用底层模型不同，他们之间底层实现方式以及与客户端之间通行的应用协议不一样，Redis直接自己构建了VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去请求和移动。

2. 我可以问一下啥是上下文切换吗？

   答：就是线程切换的时候，线程中的数据也需要切换。

3. 那他是单线程的，我们现在服务器都是多核的，那不是很浪费吗？

   答：我们可以通过在单机开多个redis实例？ 有点牵强了。。。

4. 既然提到单机会有瓶颈，那你们是怎么解决瓶颈这个问题的？

   答：我们用到了集群的部署方式，也就是**Redis cluster，并且是主从同步读写分离**，类似Mysql的主从同步，Redis cluster 支撑N个Redis master node，**每个master node都可以挂载多个slave node。**这样，整个redis就可以横向扩容，如果你要支撑更大数据量的缓存，那就横向扩容更多的master节点，每个master节点就能存放更多的数据了。

5. 那他们之间是怎么进行数据交换的？以及Redis是怎么进行持久化的？Redis数据都在内存中，一断电或者重启不就木有了嘛？

   答： 持久化是Redis高可用中比较重要的一个环节，因为Redis数据在内存的特性，持久化是必须有的，我知道的持久化有两种方式：

   - RDB：**RDB**持久化机制，是对Redis中的数据执行周期性的持久化。
   - AOF：**AOF**机制对每条写入命令生成日志，以**append-only**的模式写入一个日志文件中，因为这个模式是只追加的方式，所以没有任何磁盘寻址的开销，所以很快，有点像mysql中的binlog。

   两种方式都可以把Redis内存中的数据持久化到磁盘，然后再将这些数据备份到别的地方去，**RDB更适合做冷备，AOF更适合做热备**。

   > Tip: 两种机制全部开启的时候，Redis在重启的时候会默认使用AOF去重新构建数据，因为AOF的数据是比RDB更完整的。

6. 那两种备份机制各自优缺点是啥？

   RDB：

   - 优点：它会生成很多文件，每个数据文件分别代表了某一时刻Redis里面的数据，这种方式，有没有觉得很适合做冷备，运维设置定时任务，定时同步到远端的服务器。**RDB对Redis的性能影响非常小**，是因为在同步数据的时候，他只是fork了一个子进程去做持久化，而且他在恢复数据的时候速度比AOF更快。
   - 缺点：RDB是快照文件，都是默认五分钟甚至是更久的时间才会生成一次，意味着你这次同步到下次同步者中间五分钟的数据都很可能全部丢失掉。AOF则最多丢一秒的数据。还有就是RDB在生成数据快照的时候，程序可能会暂停几毫秒甚至几秒，这在电商秒杀中是不允许的。

   AOF：

   - 优点：
     - AOF是一秒一次去通过一个后台线程fsync操作，那最多丢这一秒的数据。
     - AOF在对日志文件进行操作的时候是以append-only的方式去写的，他只是以追加的方式写数据，自然就少了很多磁盘寻址的开销，写入性能惊人，文件也不容易损坏。
     - AOF日志通过一个叫**非常可读**的方式记录的，这样的特性就适合做灾难性数据误删除的紧急恢复了。
   - 缺点：
     - 一样的数据，AOF文件比RDB文件大
     - AOF开启后，Redis支持写的QPS比RDB支持写的要低。

7. 那两者怎么选择呢？

   答：单独用RDB，会丢失很多数据；单独用AOF，数据恢复没RDB来的快，出问题的时候用RDB恢复，再用AOF补全。

8. Redis还有其他保证集群高可用的方式吗？ （sentinel）

   答：可以使用哨兵集群模式，哨兵必须用三个实例去保证自己的健壮性，哨兵+主从并不能保证数据不丢失，但是可以保证集群的高可用。

   哨兵组件的主要功能：

   - 集群监控：负责监控Redis master和Redis slave进程是否健康
   - 消息通知：如果某个Redis 实例有故障，那么哨兵会负责发送消息作为报警通知给管理元。
   - **故障转移**：如果master node挂掉了，会自动转移到slave node上
   - 配置中心：如果故障转移发生了，通知client客户端，新的master地址

9. 我还记得你提到了主从同步，能说一下主从之间的数据怎么同步的吗？

   答：我先说一下为什么要用主从这种架构吧，前面提到了单机的QPS是有上限的，而且Redis的特性就是必须支持**读高并发**，那你一台机器又写又读，单机redis肯定顶不住。但是可以让master机器去写，数据同步给别的slave汲取，他们都拿去读，分发掉大量的请求，那是不是要好很多，而且扩容的时候还可以轻松实现水平扩容。

   如何同步：当启动一台slave的时候，它会发送一条**psync**命令给master，如果是这个slave第一次连接到master，它会触发一个全量复制。master会启动一个线程生成**RDB**快照，还会把新的写请求都缓存在内存中，RDB文件生成后，master会将这个RDB发送给slave的，**slave拿到之后做的第一件事就是写进本地的磁盘，然后加载进内存**，然后master会把内存里面的缓存的那些新命令都发给slave。

10. 数据传输的时候断网，或者服务器挂了怎么办？

    答：传输过程中有网络问题会自动重连，并且连接之后会把缺少的数据补上的。

11. 你能说一下它的内存淘汰机制吗？手写一下LRU代码？

    答：redis的过期策略，是有定期删除+惰性删除两种

12. 为啥不扫描全部设置了过期时间的key呢？

    答：性能损耗太严重了。所以官方也没有这样实现

13. 如果一直没随机到很多key，里面不就存在大量的无效key了？

    答：惰性也就是，只有key被访问的时候才会查看它是否过期，确实会有无效的key。但是我们还设置了定期删除，所以问题也不是太大。

14. **内存淘汰机制**？

    答：内存淘汰机制有以下几个：

    - noevication：不驱逐，直接返回错误，当内存限制达到并且客户端尝试执行会让更多内存被使用的命令
    - allkeys-lru：
    - valatile-lru：
    - allkeys-random：
    - volatile-random：
    - volatile-ttl：
    - 

15. 